defmodule Emissary.UUID7 do
  @moduledoc """
  UUID v7 generator compliant with RFC 9562.

  UUID v7 provides time-ordered, random UUIDs suitable for database keys
  and correlation IDs. The format guarantees:
  - Time-ordering (UUIDs generated later sort after earlier ones)
  - Uniqueness through random components
  - 48-bit timestamp with millisecond precision

  ## Format (RFC 9562)

  ```
   0                   1                   2                   3
   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                         unix_ts_ms (32 bits)                  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |          unix_ts_ms (16)      |  ver  |  rand_a (12 bits)     |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |var|         rand_b (62 bits)                                  |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  |                         rand_b (cont)                         |
  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  ```

  ## Usage

      # Generate a raw UUID v7
      iex> Emissary.UUID7.generate()
      "018f3d3c-5b10-7abc-8def-123456789012"

      # Generate a prefixed ID
      iex> Emissary.UUID7.generate_id("req")
      "req_018f3d3c-5b10-7abc-8def-123456789012"

      # Standard prefixes
      iex> Emissary.UUID7.request_id()
      "req_018f3d3c-..."

      iex> Emissary.UUID7.execution_id()
      "exec_018f3d3c-..."

      iex> Emissary.UUID7.session_id()
      "sess_018f3d3c-..."

      iex> Emissary.UUID7.build_id()
      "build_018f3d3c-..."
  """

  @version 7
  @variant 0b10

  @doc """
  Generate a UUID v7 string.

  Returns a standard UUID string format: `xxxxxxxx-xxxx-7xxx-yxxx-xxxxxxxxxxxx`
  where `7` indicates version 7 and `y` is 8, 9, a, or b (variant 1).

  ## Examples

      iex> uuid = Emissary.UUID7.generate()
      iex> String.length(uuid)
      36
      iex> String.at(uuid, 14)
      "7"

  """
  @spec generate() :: String.t()
  def generate do
    generate_at(System.system_time(:millisecond))
  end

  @doc """
  Generate a UUID v7 at a specific timestamp (milliseconds since Unix epoch).

  Useful for testing or replaying events.
  """
  @spec generate_at(non_neg_integer()) :: String.t()
  def generate_at(timestamp_ms) when is_integer(timestamp_ms) and timestamp_ms >= 0 do
    # Get 10 bytes of random data (80 bits)
    random_bytes = :crypto.strong_rand_bytes(10)

    # Extract rand_a (12 bits) and rand_b (62 bits) from the random bytes
    # We need 74 bits total, so we use all 80 bits and ignore some
    <<rand_a::12, _::4, rand_b::62, _::2>> = random_bytes

    # Construct the UUID binary (128 bits total)
    # Bits 0-47: timestamp (48 bits)
    # Bits 48-51: version = 7 (4 bits)
    # Bits 52-63: rand_a (12 bits)
    # Bits 64-65: variant = 10 (2 bits)
    # Bits 66-127: rand_b (62 bits)

    uuid_binary = <<
      timestamp_ms::48,
      @version::4,
      rand_a::12,
      @variant::2,
      rand_b::62
    >>

    format_uuid(uuid_binary)
  end

  @doc """
  Generate a prefixed ID using UUID v7.

  ## Examples

      iex> id = Emissary.UUID7.generate_id("req")
      iex> String.starts_with?(id, "req_")
      true

      iex> id = Emissary.UUID7.generate_id("exec")
      iex> String.starts_with?(id, "exec_")
      true

  """
  @spec generate_id(String.t()) :: String.t()
  def generate_id(prefix) when is_binary(prefix) do
    "#{prefix}_#{generate()}"
  end

  @doc """
  Generate a request ID (`req_<uuid7>`).

  Request IDs are generated by Emissary for every MCP request.
  """
  @spec request_id() :: String.t()
  def request_id, do: generate_id("req")

  @doc """
  Generate an execution ID (`exec_<uuid7>`).

  Execution IDs are generated by Opus for each component execution.
  """
  @spec execution_id() :: String.t()
  def execution_id, do: generate_id("exec")

  @doc """
  Generate a session ID (`sess_<uuid7>`).

  Session IDs are generated by Emissary on session initialization.
  """
  @spec session_id() :: String.t()
  def session_id, do: generate_id("sess")

  @doc """
  Generate a build ID (`build_<uuid7>`).

  Build IDs are generated by Locus for each build.
  """
  @spec build_id() :: String.t()
  def build_id, do: generate_id("build")

  @doc """
  Extract the timestamp from a UUID v7 string.

  Returns the milliseconds since Unix epoch, or `{:error, reason}` if invalid.

  ## Examples

      iex> uuid = Emissary.UUID7.generate()
      iex> {:ok, ts} = Emissary.UUID7.extract_timestamp(uuid)
      iex> is_integer(ts) and ts > 0
      true

  """
  @spec extract_timestamp(String.t()) :: {:ok, non_neg_integer()} | {:error, term()}
  def extract_timestamp(uuid) when is_binary(uuid) do
    # Handle prefixed IDs
    uuid_part = extract_uuid_part(uuid)

    case parse_uuid(uuid_part) do
      {:ok, binary} ->
        <<timestamp_ms::48, _rest::80>> = binary
        {:ok, timestamp_ms}

      {:error, _} = error ->
        error
    end
  end

  @doc """
  Check if two UUID v7s are in chronological order.

  Returns `true` if `uuid1` was generated before `uuid2`.
  """
  @spec before?(String.t(), String.t()) :: boolean()
  def before?(uuid1, uuid2) do
    with {:ok, ts1} <- extract_timestamp(uuid1),
         {:ok, ts2} <- extract_timestamp(uuid2) do
      ts1 < ts2
    else
      _ -> false
    end
  end

  # ============================================================================
  # Private Functions
  # ============================================================================

  # Format 16 bytes as a UUID string
  defp format_uuid(<<a::32, b::16, c::16, d::16, e::48>>) do
    [
      Integer.to_string(a, 16) |> String.pad_leading(8, "0"),
      "-",
      Integer.to_string(b, 16) |> String.pad_leading(4, "0"),
      "-",
      Integer.to_string(c, 16) |> String.pad_leading(4, "0"),
      "-",
      Integer.to_string(d, 16) |> String.pad_leading(4, "0"),
      "-",
      Integer.to_string(e, 16) |> String.pad_leading(12, "0")
    ]
    |> IO.iodata_to_binary()
    |> String.downcase()
  end

  # Parse UUID string to binary
  defp parse_uuid(uuid) when byte_size(uuid) == 36 do
    case String.split(uuid, "-") do
      [a, b, c, d, e] when byte_size(a) == 8 and byte_size(b) == 4 and
                          byte_size(c) == 4 and byte_size(d) == 4 and byte_size(e) == 12 ->
        try do
          binary = <<
            String.to_integer(a, 16)::32,
            String.to_integer(b, 16)::16,
            String.to_integer(c, 16)::16,
            String.to_integer(d, 16)::16,
            String.to_integer(e, 16)::48
          >>
          {:ok, binary}
        rescue
          ArgumentError -> {:error, :invalid_uuid}
        end

      _ ->
        {:error, :invalid_uuid}
    end
  end

  defp parse_uuid(_), do: {:error, :invalid_uuid}

  # Extract UUID part from prefixed ID
  defp extract_uuid_part(id) do
    case String.split(id, "_", parts: 2) do
      [_prefix, uuid] -> uuid
      [uuid] -> uuid
    end
  end
end
