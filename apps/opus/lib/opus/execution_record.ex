defmodule Opus.ExecutionRecord do
  @moduledoc """
  Struct and storage for WASM execution records.

  Execution records capture the complete state of a component execution
  for auditing, debugging, and forensic replay purposes.

  ## Storage

  Records are stored in SQLite via `Arca.MCP.handle("execution", ...)` which
  routes through the MCP boundary to the `executions` table. The crash-resilient
  pattern writes a "started" record BEFORE execution begins, and updates it with
  completion/failure data AFTER execution finishes.

  If an execution record exists with status "running" but no completion,
  the execution crashed or was interrupted.

  ## Usage

      # Create and write started record BEFORE execution
      record = ExecutionRecord.new(ctx, reference, input)
      :ok = ExecutionRecord.write_started(record)

      # Execute...

      # On success: write completion
      record = ExecutionRecord.complete(record, output)
      :ok = ExecutionRecord.write_completed(record)

      # On failure: write failure
      record = ExecutionRecord.fail(record, error)
      :ok = ExecutionRecord.write_failed(record)

  ## Correlation IDs

  All IDs use UUID v7 (RFC 9562) format for time-ordering:
  - `execution_id`: `exec_<uuid7>` - Generated by Opus for each execution
  - `request_id`: `req_<uuid7>` - From the MCP request context (if available)
  """

  alias Sanctum.Context

  @type t :: %__MODULE__{
          id: String.t(),
          request_id: String.t() | nil,
          user_id: String.t(),
          reference: map(),
          component_type: Opus.ComponentType.t(),
          component_digest: String.t() | nil,
          input: map(),
          output: map() | nil,
          status: :running | :completed | :failed | :cancelled,
          started_at: DateTime.t(),
          completed_at: DateTime.t() | nil,
          duration_ms: non_neg_integer() | nil,
          error: String.t() | nil,
          host_policy: map() | nil,
          wasi_trace: list() | nil,
          parent_execution_id: String.t() | nil
        }

  defstruct [
    :id,
    :request_id,
    :user_id,
    :reference,
    :component_type,
    :component_digest,
    :input,
    :output,
    :status,
    :started_at,
    :completed_at,
    :duration_ms,
    :error,
    :host_policy,
    :wasi_trace,
    :parent_execution_id
  ]

  @doc """
  Create a new execution record when starting execution.

  Options:
  - `:component_type` - The component type (:catalyst, :reagent, :formula). Defaults to :reagent.
  - `:component_digest` - The SHA256 digest of the WASM component.
  - `:host_policy` - Snapshot of the host policy applied to this execution.
  - `:parent_execution_id` - Parent formula execution ID for sub-invocations.
  """
  @spec new(Context.t(), map(), map(), keyword()) :: t()
  def new(%Context{} = ctx, reference, input, opts \\ []) do
    component_type = Keyword.get(opts, :component_type, :reagent)
    component_digest = Keyword.get(opts, :component_digest)
    host_policy = Keyword.get(opts, :host_policy)
    parent_execution_id = Keyword.get(opts, :parent_execution_id)

    %__MODULE__{
      id: generate_id(),
      request_id: ctx.request_id,
      user_id: ctx.user_id,
      reference: reference,
      component_type: component_type,
      component_digest: component_digest,
      input: input,
      output: nil,
      status: :running,
      started_at: DateTime.utc_now(),
      completed_at: nil,
      duration_ms: nil,
      error: nil,
      host_policy: host_policy,
      wasi_trace: nil,
      parent_execution_id: parent_execution_id
    }
  end

  @doc """
  Mark execution as completed with output.

  Options:
  - `:wasi_trace` - Optional WASI call trace for forensic replay.
  """
  @spec complete(t(), map(), keyword()) :: t()
  def complete(%__MODULE__{} = record, output, opts \\ []) do
    now = DateTime.utc_now()
    duration_ms = DateTime.diff(now, record.started_at, :millisecond)
    wasi_trace = Keyword.get(opts, :wasi_trace)

    %{record |
      output: output,
      status: :completed,
      completed_at: now,
      duration_ms: duration_ms,
      wasi_trace: wasi_trace
    }
  end

  @doc """
  Mark execution as failed with error message.

  Options:
  - `:wasi_trace` - Optional WASI call trace for forensic replay.
  """
  @spec fail(t(), String.t(), keyword()) :: t()
  def fail(%__MODULE__{} = record, error, opts \\ []) do
    now = DateTime.utc_now()
    duration_ms = DateTime.diff(now, record.started_at, :millisecond)
    wasi_trace = Keyword.get(opts, :wasi_trace)

    %{record |
      status: :failed,
      error: error,
      completed_at: now,
      duration_ms: duration_ms,
      wasi_trace: wasi_trace
    }
  end

  @doc """
  Cancel a running execution.

  Only running executions can be cancelled. Returns:
  - `{:ok, record}` - Successfully cancelled
  - `{:error, :not_found}` - Execution not found
  - `{:error, :not_cancellable}` - Execution already completed/failed/cancelled
  """
  @spec cancel(Context.t(), String.t()) :: {:ok, t()} | {:error, :not_found | :not_cancellable | term()}
  def cancel(%Context{} = ctx, id) do
    case get(ctx, id) do
      {:ok, %{status: :running} = record} ->
        now = DateTime.utc_now()
        duration_ms = DateTime.diff(now, record.started_at, :millisecond)

        cancelled_record = %{record | status: :cancelled, completed_at: now, duration_ms: duration_ms}

        case write_failed(cancelled_record) do
          :ok -> {:ok, cancelled_record}
          error -> error
        end

      {:ok, _record} ->
        {:error, :not_cancellable}

      {:error, :not_found} ->
        {:error, :not_found}

      error ->
        error
    end
  end

  # ============================================================================
  # Storage API (delegates to Arca.MCP)
  # ============================================================================

  @doc """
  Write execution start record BEFORE execution begins.

  This must be called before starting WASM execution to ensure crash resilience.
  """
  @spec write_started(t()) :: :ok | {:error, term()}
  def write_started(%__MODULE__{} = record) do
    ctx = make_ctx(record)

    case Arca.MCP.handle("execution", ctx, %{
      "action" => "record_start",
      "id" => record.id,
      "request_id" => record.request_id,
      "reference" => encode_reference(record.reference),
      "input_hash" => nil,
      "user_id" => record.user_id,
      "component_type" => to_string(record.component_type),
      "component_digest" => record.component_digest,
      "started_at" => DateTime.to_iso8601(record.started_at),
      "input" => record.input,
      "host_policy" => record.host_policy,
      "parent_execution_id" => record.parent_execution_id
    }) do
      {:ok, %{recorded: true}} -> :ok
      {:error, reason} -> {:error, reason}
    end
  end

  @doc """
  Write execution completion record AFTER successful execution.
  """
  @spec write_completed(t()) :: :ok | {:error, term()}
  def write_completed(%__MODULE__{status: :completed} = record) do
    ctx = make_ctx(record)

    case Arca.MCP.handle("execution", ctx, %{
      "action" => "record_complete",
      "id" => record.id,
      "completed_at" => DateTime.to_iso8601(record.completed_at),
      "duration_ms" => record.duration_ms,
      "status" => "completed",
      "output" => record.output,
      "wasi_trace" => record.wasi_trace
    }) do
      {:ok, %{recorded: true}} -> :ok
      {:error, reason} -> {:error, reason}
    end
  end

  def write_completed(%__MODULE__{status: status}) do
    {:error, "Cannot write completed record for status: #{status}"}
  end

  @doc """
  Write execution failure record AFTER failed or cancelled execution.
  """
  @spec write_failed(t()) :: :ok | {:error, term()}
  def write_failed(%__MODULE__{status: status} = record) when status in [:failed, :cancelled] do
    ctx = make_ctx(record)

    case Arca.MCP.handle("execution", ctx, %{
      "action" => "record_complete",
      "id" => record.id,
      "completed_at" => DateTime.to_iso8601(record.completed_at),
      "duration_ms" => record.duration_ms,
      "status" => Atom.to_string(status),
      "error_message" => record.error,
      "wasi_trace" => record.wasi_trace
    }) do
      {:ok, %{recorded: true}} -> :ok
      {:error, reason} -> {:error, reason}
    end
  end

  def write_failed(%__MODULE__{status: status}) do
    {:error, "Cannot write failed record for status: #{status}"}
  end

  @doc """
  Load an execution record by ID.
  """
  @spec get(Context.t(), String.t()) :: {:ok, t()} | {:error, term()}
  def get(%Context{} = ctx, id) do
    case Arca.MCP.handle("execution", ctx, %{"action" => "get", "id" => id}) do
      {:ok, result} ->
        if result.user_id == ctx.user_id do
          {:ok, from_mcp_result(result)}
        else
          {:error, :not_found}
        end

      {:error, _} ->
        {:error, :not_found}
    end
  end

  @doc """
  List execution records for the current user.

  Options:
  - `:limit` - Maximum number of records (default: 20)
  - `:status` - Filter by status (:running, :completed, :failed, :all)
  """
  @spec list(Context.t(), keyword()) :: {:ok, [t()]} | {:error, term()}
  def list(%Context{} = ctx, opts \\ []) do
    limit = Keyword.get(opts, :limit, 20)
    status_filter = Keyword.get(opts, :status, :all)

    args = %{
      "action" => "list",
      "limit" => limit,
      "user_id" => ctx.user_id
    }

    args = if status_filter != :all, do: Map.put(args, "status", to_string(status_filter)), else: args

    case Arca.MCP.handle("execution", ctx, args) do
      {:ok, %{executions: executions}} ->
        {:ok, Enum.map(executions, &from_mcp_result/1)}

      {:error, reason} ->
        {:error, reason}
    end
  end

  # ===========================================================================
  # Private - Struct Conversion
  # ===========================================================================

  defp from_mcp_result(result) when is_map(result) do
    %__MODULE__{
      id: result.id,
      request_id: result.request_id,
      user_id: result.user_id,
      reference: parse_json_or_nil(result.reference),
      component_type: parse_component_type(result.component_type),
      component_digest: result.component_digest,
      input: parse_json_or_nil(result.input) || %{},
      output: parse_json_or_nil(result.output),
      status: parse_status(result.status),
      started_at: parse_datetime_value(result.started_at),
      completed_at: parse_datetime_value(result.completed_at),
      duration_ms: result.duration_ms,
      error: result.error_message,
      host_policy: parse_json_or_nil(result.host_policy),
      wasi_trace: parse_json_or_nil(result.wasi_trace),
      parent_execution_id: result[:parent_execution_id]
    }
  end

  defp parse_json_or_nil(nil), do: nil
  defp parse_json_or_nil(json) when is_binary(json) do
    case Jason.decode(json) do
      {:ok, map} -> map
      _ -> nil
    end
  end
  defp parse_json_or_nil(other), do: other

  defp parse_status(nil), do: :running
  defp parse_status("running"), do: :running
  defp parse_status("completed"), do: :completed
  defp parse_status("failed"), do: :failed
  defp parse_status("cancelled"), do: :cancelled
  defp parse_status(_), do: :running

  defp parse_datetime_value(nil), do: nil
  defp parse_datetime_value(%DateTime{} = dt), do: dt
  defp parse_datetime_value(iso_string) when is_binary(iso_string) do
    case DateTime.from_iso8601(iso_string) do
      {:ok, dt, _offset} -> dt
      _ -> nil
    end
  end
  defp parse_datetime_value(_), do: nil

  # ===========================================================================
  # Private
  # ===========================================================================

  defp generate_id do
    "exec_#{Ecto.UUID.generate()}"
  end

  defp encode_reference(ref) when is_map(ref), do: Jason.encode!(ref)
  defp encode_reference(ref) when is_binary(ref), do: ref
  defp encode_reference(nil), do: nil

  # Build a minimal internal context for writing execution records.
  defp make_ctx(record) do
    %Context{
      user_id: record.user_id,
      permissions: MapSet.new([:execution_write, :storage_write, :storage_read]),
      scope: :personal,
      auth_method: :local,
      api_key_type: :admin
    }
  end

  defp parse_component_type(nil), do: :reagent
  defp parse_component_type(type_str) when is_binary(type_str) do
    case Opus.ComponentType.parse(type_str) do
      {:ok, type} -> type
      {:error, _} -> :reagent
    end
  end
  defp parse_component_type(_), do: :reagent
end
